# 1、单例模式使用场景
  在一个系统中，要求一个类有且仅有一个对象，如果出现多个对象就会出现“不良反
应”，可以采用单例模式，具体的场景如下：
● 要求生成唯一序列号的环境；
● 在整个项目中需要一个共享访问点或共享数据，例如一个Web页面上的计数器，可以
不用把每次刷新都记录到数据库中，使用单例模式保持计数器的值，并确保是线程安全的；
● 创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源；
● 需要定义大量的静态常量和静态方法（如工具类）的环境，可以采用单例模式（当
然，也可以直接声明为static的方式）。

# 2、工厂方法模式
首先，工厂方法模式是new一个对象的替代品，所以在所有需要生成对象的地方都可以
使用，但是需要慎重地考虑是否要增加一个工厂类进行管理，增加代码的复杂度。
其次，需要灵活的、可扩展的框架时，可以考虑采用工厂方法模式。万物皆对象，那万
物也就皆产品类，例如需要设计一个连接邮件服务器的框架，有三种网络协议可供选择：
POP3、IMAP、HTTP，我们就可以把这三种连接方法作为产品类，定义一个接口如
IConnectMail，然后定义对邮件的操作方法，用不同的方法实现三个具体的产品类（也就是
连接方式）再定义一个工厂方法，按照不同的传入条件，选择不同的连接方式。如此设计，
可以做到完美的扩展，如某些邮件服务器提供了WebService接口，很好，我们只要增加一个
产品类就可以了。
再次，工厂方法模式可以用在异构项目中，例如通过WebService与一个非Java的项目交
互，虽然WebService号称是可以做到异构系统的同构化，但是在实际的开发中，还是会碰到
很多问题，如类型问题、WSDL文件的支持问题，等等。从WSDL中产生的对象都认为是一
个产品，然后由一个具体的工厂类进行管理，减少与外围系统的耦合。
最后，可以使用在测试驱动开发的框架下。例如，测试一个类A，就需要把与类A有关
联关系的类B也同时产生出来，我们可以使用工厂方法模式把类B虚拟出来，避免类A与类B
的耦合。目前由于JMock和EasyMock的诞生，该使用场景已经弱化了，读者可以在遇到此种
情况时直接考虑使用JMock或EasyMock

# 3、模板方法
● 多个子类有公有的方法，并且逻辑基本相同时。
● 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个
子类实现。
● 重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通
过钩子函数（见“模板方法模式的扩展”）约束其行为。

# 4、建造者模式
● 相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。
● 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可
以使用该模式。
● 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建
造者模式非常合适。
● 在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程
中不易得到时，也可以采用建造者模式封装该对象的创建过程。该种场景只能是一个补偿方
法，因为一个对象不容易获得，而在设计阶段竟然没有发觉，而要通过创建者模式柔化创建
过程，本身已经违反设计的最初目标。




















